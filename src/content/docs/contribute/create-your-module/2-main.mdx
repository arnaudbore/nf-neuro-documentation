---
title: Process definition
description: Edit the process definition in the `main.nf` file.
coloredPrefix:
  - text: "${"
    style: text-rose-400
  - text: prefix
    style: text-orange-300
  - text: "}"
    style: text-rose-400
coloredDenoised:
  - text: "${"
    style: text-rose-400
  - text: prefix
    style: text-orange-300
  - text: "}"
    style: text-rose-400
  - text: "__denoised.nii.gz"
    style: text-orange-300
taskDotExt:
  - text: task
    style: text-slate-200
  - text: "."
    style: text-emerald-400
  - text: ext
    style: text-slate-200
---

import { Steps } from '@astrojs/starlight/components';
import InlineCode from '../../../../components/InlineCode.astro';

With the module's skeleton ready, it's time to edit the **script** section and upon
it the **inputs** and **outputs** of the process definition. For now, open the `main.nf`
file. We'll go through the following steps in order :

<Steps>
1. [Write the script section](#Write-the-script)
2. [Define the inputs and outputs](#Define-the-inputs-and-outputs)
3. [Add dependencies versioning](#Obligatory-version-yml-output)
4. [Define a stub for quick test](#Define-a-stub-for-quick-testing)
</Steps>

### Write the script

The script section is defined in two parts : the **groovy header** and the **bash script**.

```groovy
script:
    def GROOVY HEADER GOES HERE !
    """
    BASH SCRIPT GOES HERE !
    """
```

In the **groovy header**, you can define variables and modify them using the power of the
[groovy language](https://groovy-lang.org/). You can see the `args` and `prefix` variables
already defined for you by the template :

- The `args` variable is a list of custom arguments to pass to command lines inside the **bash script**. Users of
your module can define it in their configuration to change the behavior of your module

- The `prefix` variable is the prefix to use for all files outputed by your module.

The **bash script** contains the commands that will be run at execution of your module. It is contained in between
**triple quotes**. In the script, you have access to :

- All terminal commands, from the system (e.g. `cd`, `ls`, `find`) and those installed by dependencies (e.g. scilpy commands
such as `scil_denoising_nlmeans.py`)
- Environment variables available at runtime (`PATH` and others). Use the prefix <span class="text-blue-400">\\$</span> (e.g. `\$PATH`)
- Variables defined in the **groovy header**, in the `input` and `output` sections and through the `task` object. Use
the prefix <span class="text-blue-400">$</span> (e.g. `$prefix` or `$task.cpus`)

:::caution
Variables defined in the `params` map of `nextflow.config` files are also available, but their usage is prohibited,
reserved for workflow confguration.
:::

Replace the whole script section with the following definition of the denoising command :

```groovy
script:
    def prefix = task.ext.prefix ?: "${meta.id}"
    def args = task.ext.args ?: []
    """
    export ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1
    export OMP_NUM_THREADS=1
    export OPENBLAS_NUM_THREADS=1

    scil_denoising_nlmeans.py $image ${prefix}__denoised.nii.gz ${args.join(" ")} --processes $tasks.cpus
    """
```

:::tip[What is happening here ?]
<Steps>
1. In the **groovy header**, two variables are defined for you : the **prefix** and the **args** list. They both use the
   [elvis operator](https://groovy-lang.org/operators.html#_elvis_operator) <span class="text-emerald-400">?:</span>, a
   shorthand of an `if-else` conditional statement, to select between a value defined in <InlineCode parts={frontmatter.taskDotExt} />
   or a default value.
2. The default value for the **prefix** is defined throught the <span class="text-orange-300">meta</span> variable, which is an
   [obligatory input](https://nf-co.re/docs/contributing/components/meta_map) containing the metadata associated with the subject.
   It's usage is defined later.
3. The scilpy command can handle its own parallelization. Using <span class="text-orange-300">export</span>,
   we declared **3 environment variables** to limit the threads used by dependencies (e.g. `ITK`, `OMP`, `OPENBLAS`).
4. The <span class="text-orange-300">scil_denoising_nlmeans.py</span> command is called on an input
   <span class="text-lime-300">$image</span>, a variable you will define in the **input** section later.
5. The denoised image is written to a file named <InlineCode parts={frontmatter.coloredDenoised} />, where
   <InlineCode parts={frontmatter.coloredPrefix} /> is the prefix defined in the **groovy header** (the brackets usage
   is equivalent to <span class="text-lime-300">$prefix</span>). You will define an **output** to catch this file later.
6. The user's custom arguments are passed to the command, by unraveling the <span class="text-orange-300">args</span> variable
   using <span class="text-orange-300">join</span>, a **groovy** operator.
7. The <span class="text-lime-300">$task.cpus</span> variable is used to limit the number of threads used by the command to
   the number of CPUs allocated to the process. If the command allows it, this can also be done for memory
   (<span class="text-lime-300">$task.memory</span>) and other [process](https://www.nextflow.io/docs/latest/reference/process.html)
   properties and directives.
</Steps>
:::

### Define the inputs and outputs

The **input** section of the process define how users of your module shape and structure the data passed
to it for processing. In the same manner, the **output** section define how you shape and structure the data
processed by the module, how the user collects it for usage in other downstream processes.

:::caution
Declaring an output doesn't mean **publishing an output to results**. This task is handled by the `publishDir` directive,
which is the topic of a later section.
:::

#### The input section

The input section is defined on multiple lines, each line stating a different input channel.

```groovy
input:
    CHANNEL_1
    CHANNEL_2
    ...
```

:::note
Each channel defined below `input:` is independent. Their elements **have no association**
with each other, as the dataflow in Nextflow is **asynchronous**. This means that the elements in each channel
are processed independently and in parallel, without any direct relationship between them, **unless stated
otherwise**.
:::

Each channel describes the **structure** of the elements that pass through it. From the **script** we defined above, we know
that two variables an input : the <span class="text-orange-300">meta</span> and the <span class="text-lime-300">image</span>.
We can't define them in separate channels, since the metadata is associated with the image. Instead, we state we want them
grouped using a `tuple` :

```diff lang="groovy"
+input:
+    tuple val(meta), path(image)
script:
    def prefix = task.ext.prefix ?: "${meta.id}"
    def args = task.ext.args ?: []
    """
    export ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1
    export OMP_NUM_THREADS=1
    export OPENBLAS_NUM_THREADS=1

    scil_denoising_nlmeans.py $image ${prefix}__denoised.nii.gz ${args.join(" ")} --processes $tasks.cpus
    """
```

:::note
  In **nextflow**, the main [datatypes](https://www.nextflow.io/docs/latest/reference/process.html#inputs) are `val`, to
  define a groovy variable (e.g. number, string, map, list), and `path`, a local or remote filesystem location. `tuple`
  is only used at the beginning of a channel definition, to indicate elements are groups of values. For a comprehensive
  overview of channels, refer to the [Nextflow documentation](https://www.nextflow.io/docs/latest/channel.html) and
  [Nextflow hello tutorials](https://training.nextflow.io/latest/hello_nextflow/02_hello_channels/).
:::

#### Optional input value

Denoising with the Non-Local Means algorithm can be accelerated and improved using a mask. This
mask is optional, so we need to define it as such. In **nextflow**, there is no concept of
optional inputs. This is a limitation of the language itself, not of the framework. However,
we can work around this using **default null values**.

:::note
A **default null value** can be detected and skipped inside the script section, using the
[groovy truth](https://groovy-lang.org/semantics.html#the-groovy-truth) and bash operations.
For **a path**, the default value is the **empty list** `[]`. For the various types encompassed
by **val**, refer to the link above.
:::

```diff lang="groovy" ins=", path(mask) /* optional, input = [] */" ins=" $input_mask" {"1": 2} {"2": 6} {"3": 12}
input:
    tuple val(meta), path(image), path(mask) /* optional, input = [] */
script:
    def prefix = task.ext.prefix ?: "${meta.id}"
    def args = task.ext.args ?: []
+    def input_mask = mask ? "--mask_denoise $mask" : ""
    """
    export ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1
    export OMP_NUM_THREADS=1
    export OPENBLAS_NUM_THREADS=1

    scil_denoising_nlmeans.py $image ${prefix}__denoised.nii.gz $input_mask ${args.join(" ")} --processes $tasks.cpus
    """
```

:::tip[What is happening here ?]
<Steps>
1. We added the optional `path(mask)` input, with the comment `/* optional, input = [] */`
   to indicate so. This is not a requirement, since we will document this later, but it is
   a good practice nonetheless.
2. We defined a new variable <span class="text-slate-200">input_mask</span> in the **groovy header**.
   This variable will be used to store the value of the mask argument if the mask is present. To do so,
   we use the [groovy truth](https://groovy-lang.org/semantics.html#the-groovy-truth), which states the
   empty list <span class="text-slate-200">[]</span> is equivalent to <span class="text-blue-300">false</span>,
   combined with the [ternary operator](https://groovy-lang.org/operators.html#_ternary_operator).
3. The <span class="text-slate-200">input_mask</span> variable is then used in the **bash script** to pass the
   mask to the command. If the mask is not present, the variable will be an empty string, which is
   equivalent to not passing the argument at all.
</Steps>
:::

#### The output section

Like the input section, the output section is defined on multiple lines, each line defining a different output channel.
The difference is that each channel gets a name, using the identifier `emit:`, and can be tagged as `optional:`.

```groovy
output:
    CHANNEL_1, emit: <name>
    CHANNEL_2, emit: <name>, optional: true
    ...
```

:::caution
An **optional output** doesn't emit default values. In case no values are caught, it is simply **empty**.
:::

To define an output file, use the `path` type, along with a **glob pattern** that targets it. For the current
module, the output file to target is the denoised image named : <InlineCode parts={frontmatter.coloredDenoised} />.
Only the <InlineCode parts={frontmatter.coloredPrefix} /> part changes, caught by the pattern :
<span class="text-orange-300">"*__denoised.nii.gz"</span>.

```diff lang="groovy"
output:
    tuple val(meta), path("*__denoised.nii.gz"), emit: image
```

:::note
The denoised image, as for the input image, is bound to metadata. For this reason, the output elements
**MUST** be grouped in a `tuple` with the metadata as well.
:::

Replace the full process content with this snippet :

```diff lang="groovy"
input:
    tuple val(meta), path(image), path(mask) /* optional, input = [] */
+output:
+    tuple val(meta), path("*__denoised.nii.gz"), emit: image
script:
    def prefix = task.ext.prefix ?: "${meta.id}"
    def args = task.ext.args ?: []
    def input_mask = mask ? "--mask_denoise $mask" : ""
    """
    export ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1
    export OMP_NUM_THREADS=1
    export OPENBLAS_NUM_THREADS=1

    scil_denoising_nlmeans.py $image ${prefix}__denoised.nii.gz $input_mask ${args.join(" ")} --processes $tasks.cpus
    """
```

### Obligatory `version.yml` output

To ensure reproducibility of software, it is mandatory you export the versions from the full
first layer dependencies used within your module (the ones called inside your script) to a `versions.yml`
file. For this module, this means exporting the version of `scilpy`, which is done by modifying the process
as follows :

```diff lang="groovy"
input:
    tuple val(meta), path(image), path(mask) /* optional, input = [] */
output:
    tuple val(meta), path("*__denoised.nii.gz"), emit: image
+    path "versions.yml", emit: versions
script:
    def prefix = task.ext.prefix ?: "${meta.id}"
    def args = task.ext.args ?: []
    def input_mask = mask ? "--mask_denoise $mask" : ""
    """
    export ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1
    export OMP_NUM_THREADS=1
    export OPENBLAS_NUM_THREADS=1

    scil_denoising_nlmeans.py $image ${prefix}__denoised.nii.gz $input_mask ${args.join(" ")} --processes $tasks.cpus

+    cat <<-END_VERSIONS > versions.yml
+    "${task.process}":
+        scilpy: \$(pip list | grep scilpy | tr -s ' ' | cut -d' ' -f2)
+    END_VERSIONS
    """
```

:::note
For `scilpy`, we used the command `pip list | grep scilpy | tr -s ' ' | cut -d' ' -f2` to extract the version. Each
software has its own way of exporting the version, so you will need to adapt this command to your needs.
:::

### Define a stub for quick testing

The `stub` section is a special script that does not get executed at runtime. Instead, it is used to
perform quick **integration tests**, using multiple modules, to verify how well they work together. In
order for a stub to be efficient, it must do three things :

<Steps>
1. Ensure all commands call by the script are available. This is often achieved by calling
   the help of the command for each of them.
2. Produce the files that are awaited as output, in their more lightweight version. This is often
   done by creating empty files using the `touch` command.
3. Export the versions of the software used in the script, using the same commands.
</Steps>

For the Non-Local Means denoising module, this means calling the help command of `scil_denoising_nlmeans.py`,
creating an empty file named <InlineCode parts={frontmatter.coloredDenoised} />, and finally exporting
the version of `scilpy` to a `versions.yml` file. To do so, replace the stub skeleton in your file with
the following :

```groovy
stub:
    def prefix = task.ext.prefix ?: "${meta.id}"
    """
    scil_denoising_nlmeans.py -h

    touch ${prefix}_denoised.nii.gz

    cat <<-END_VERSIONS > versions.yml
    "${task.process}":
        scilpy: \$(pip list | grep scilpy | tr -s ' ' | cut -d' ' -f2)
    END_VERSIONS
    """
```

:::caution
Some help commands might return non-zero exit code, which is detected by
Nextflow as an error. To avoid this, add this bash function in the stub :

```bash frame="none"
function handle_code () {
local code=\$?
ignore=( 1 )
exit \$([[ " \${ignore[@]} " =~ " \$code " ]] && echo 0 || echo \$code)
}
trap 'handle_code' ERR
```

Add or change the codes in the `ignore` array to match the ones you want to ignore,
each separated by a space.
:::

### A complete example

If you followed every step on page, you should now have a complete, guideline-abiding,
and usable `main.nf` file! Your resulting file should be closely similar to the
`denoising/nlmeans` module :

```groovy
process DENOISING_NLMEANS {

tag "$meta.id"
label 'process_medium'

container " ... "

input:
    tuple val(meta), path(image), path(mask)

output:
    tuple val(meta), path("*_denoised.nii.gz")      , emit: image
    path "versions.yml"                             , emit: versions

when:
    task.ext.when == null || task.ext.when

script:
    def prefix = task.ext.prefix ?: "${meta.id}"
    def args = task.ext.args ?: []
    def input_mask = mask ? "--mask $mask" : ""
    """
    export ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1
    export OMP_NUM_THREADS=1
    export OPENBLAS_NUM_THREADS=1

    scil_denoising_nlmeans.py $image ${prefix}__denoised.nii.gz $input_mask ${args.join(" ")} --processes $task.cpus

    cat <<-END_VERSIONS > versions.yml
    "${task.process}":
        scilpy: \$(pip list | grep scilpy | tr -s ' ' | cut -d' ' -f2)
    END_VERSIONS
    """

stub:
    def prefix = task.ext.prefix ?: "${meta.id}"
    """
    scil_denoising_nlmeans.py -h

    touch ${prefix}_denoised.nii.gz

    cat <<-END_VERSIONS > versions.yml
    "${task.process}":
        scilpy: \$(pip list | grep scilpy | tr -s ' ' | cut -d' ' -f2)
    END_VERSIONS
    """
}
```

On the next part of the tutorial, you will add parameters to the module, using the
<span class="text-slate-200">task.ext</span> that users can use to configure the commands
finely, in a verbose and user-friendly way.